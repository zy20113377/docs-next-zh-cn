(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{625:function(t,a,v){"use strict";v.r(a);var r=v(56),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"frontmatter-title"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#frontmatter-title"}},[t._v("#")]),t._v(" "+t._s(t.$frontmatter.title)+" "),v("MigrationBadges",{attrs:{badges:t.$frontmatter.badges}})],1),t._v(" "),v("h2",{attrs:{id:"概览"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概览"}},[t._v("#")]),t._v(" 概览")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("非兼容")]),t._v("：两者作用于同一个元素上时，"),v("code",[t._v("v-if")]),t._v(" 会拥有比 "),v("code",[t._v("v-for")]),t._v(" 更高的优先级。")])]),t._v(" "),v("h2",{attrs:{id:"介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),v("p",[t._v("Vue.js 中使用最多的两个指令就是 "),v("code",[t._v("v-if")]),t._v(" 和 "),v("code",[t._v("v-for")]),t._v("，因此开发者们可能会想要同时使用它们。虽然不建议这样做，但有时确实是必须的，于是我们想提供有关其工作方式的指南。")]),t._v(" "),v("h2",{attrs:{id:"_2-x-语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-x-语法"}},[t._v("#")]),t._v(" 2.x 语法")]),t._v(" "),v("p",[t._v("2.x 版本中在一个元素上同时使用 "),v("code",[t._v("v-if")]),t._v(" 和 "),v("code",[t._v("v-for")]),t._v(" 时，"),v("code",[t._v("v-for")]),t._v(" 会优先作用。")]),t._v(" "),v("h2",{attrs:{id:"_3-x-语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-x-语法"}},[t._v("#")]),t._v(" 3.x 语法")]),t._v(" "),v("p",[t._v("3.x 版本中 "),v("code",[t._v("v-if")]),t._v(" 总是优先于 "),v("code",[t._v("v-for")]),t._v(" 生效。")]),t._v(" "),v("h2",{attrs:{id:"迁移策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#迁移策略"}},[t._v("#")]),t._v(" 迁移策略")]),t._v(" "),v("p",[t._v("由于语法上存在歧义，建议避免在同一元素上同时使用两者。")]),t._v(" "),v("p",[t._v("比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。")])])}),[],!1,null,null,null);a.default=_.exports}}]);